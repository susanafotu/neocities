name: Create Blog Post from Issue
on:
  issues:
    types: [labeled]
    
jobs:
  create-post:
    if: github.event.label.name == 'ready-to-post'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
      pull-requests: write

    steps:
      - uses: actions/checkout@v4
        with:
          ref: main

      - name: Parse issue body and create files
        id: parse
        uses: actions/github-script@v7
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        with:
          script: |
            const fs = require('fs');
            const body = context.payload.issue.body;

            // Extract image URL - support both markdown and HTML img tags
            let imageUrl = '';

            // Try markdown image syntax first: ![alt](url)
            const mdImgMatch = body.match(/!\[.*?\]\((https?:\/\/[^\s)]+)\)/);
            if (mdImgMatch) {
              imageUrl = mdImgMatch[1];
            } else {
              // Try HTML img tag: <img ... src="url" ... />
              const htmlImgMatch = body.match(/<img[^>]+src=["']([^"']+)["'][^>]*\/?>/i);
              if (htmlImgMatch) {
                imageUrl = htmlImgMatch[1];
              }
            }

            // Extract title (line after Title:)
            const titleMatch = body.match(/Title:\s*([^\n]+)/);
            const title = titleMatch ? titleMatch[1].trim() : '';

            // Extract content (after Content:)
            const contentMatch = body.match(/Content:\s*([\s\S]*)/);
            const content = contentMatch ? contentMatch[1].trim() : '';

            // Generate slug from title
            const slug = title.toLowerCase()
              .replace(/[^a-z0-9\s-]/g, '')
              .replace(/\s+/g, '-')
              .replace(/-+/g, '-')
              .replace(/^-|-$/g, '');

            // Get today's date in YYYY-MM-DD format
            const date = new Date().toISOString().split('T')[0];

            // Determine image extension from URL (default to jpeg for GitHub user-attachment URLs)
            const extMatch = imageUrl.match(/\.(jpg|jpeg|png|gif|webp)(?:\?|$)/i);
            const imageExt = extMatch ? extMatch[1].toLowerCase() : 'jpeg';
            // Note: GitHub user-attachment URLs have no extension, so we default to jpeg

            console.log('Parsed values:');
            console.log('Image URL:', imageUrl);
            console.log('Title:', title);
            console.log('Slug:', slug);
            console.log('Date:', date);
            console.log('Image Extension:', imageExt);
            console.log('Content preview:', (content || '').substring(0, 100) + ((content || '').length > 100 ? '...' : ''));

            // Validate required fields (only title is required)
            if (!title) {
              core.setFailed('Title is required. Please add a title after Title:');
              return;
            }

            // Save parsed data to a JSON file for use in later steps
            const data = { imageUrl, title, content, slug, date, imageExt };
            fs.writeFileSync('parsed-data.json', JSON.stringify(data, null, 2));

            // Set simple outputs for step references
            core.setOutput('slug', slug);
            core.setOutput('title', title);
            core.setOutput('date', date);
            core.setOutput('image_ext', imageExt);
            core.setOutput('image_url', imageUrl);

      - name: Download image
        if: steps.parse.outputs.image_url != ''
        run: |
          mkdir -p public/hkia
          SLUG=$(jq -r '.slug' parsed-data.json)
          IMAGE_URL=$(jq -r '.imageUrl' parsed-data.json)
          IMAGE_EXT=$(jq -r '.imageExt' parsed-data.json)
          
          curl -L -f "$IMAGE_URL" -o "public/hkia/${SLUG}.${IMAGE_EXT}"
          echo "Downloaded: public/hkia/${SLUG}.${IMAGE_EXT}"

      - name: Generate excerpt with Claude
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          TITLE=$(jq -r '.title' parsed-data.json)
          CONTENT=$(jq -r '.content' parsed-data.json)

          echo "=== Debug: Title ===" 
          echo "$TITLE"
          echo "=== Debug: Content length ===" 
          echo "${#CONTENT}"

          # Create prompt text
          if [ -n "$CONTENT" ]; then
            PROMPT="Generate a brief, engaging blog post excerpt (1-2 sentences, under 150 characters total) for a post titled \"$TITLE\". The post content is: $CONTENT Return ONLY the excerpt text, nothing else."
          else
            PROMPT="Generate a brief, engaging blog post excerpt (1-2 sentences, under 150 characters total) for a post titled \"$TITLE\". No content provided. Return ONLY the excerpt text, nothing else."
          fi

          # Create the request payload with explicit exit code check
          echo "=== Creating request.json ==="
          if ! jq -n \
            --arg prompt "$PROMPT" \
            '{
              model: "claude-haiku-4-5",
              max_tokens: 100,
              messages: [{
                role: "user",
                content: $prompt
              }]
            }' > request.json 2>&1; then
            echo "ERROR: jq command failed"
            exit 1
          fi

          # Validate request.json exists and is not empty
          if [ ! -f request.json ] || [ ! -s request.json ]; then
            echo "ERROR: request.json not created or is empty"
            exit 1
          fi

          # Validate it's valid JSON
          echo "=== Validating request.json ==="
          if ! jq empty request.json 2>&1; then
            echo "ERROR: request.json contains invalid JSON"
            echo "=== Contents of request.json ==="
            cat request.json
            exit 1
          fi

          echo "✓ request.json is valid JSON (size: $(wc -c < request.json) bytes)"

          # Call Claude API
          echo "=== Calling Claude API ==="
          HTTP_CODE=$(curl -s -w "%{http_code}" -o response.json \
            https://api.anthropic.com/v1/messages \
            -H "x-api-key: $ANTHROPIC_API_KEY" \
            -H "anthropic-version: 2023-06-01" \
            -H "content-type: application/json" \
            -d @request.json)

          echo "HTTP Status: $HTTP_CODE"

          if [ "$HTTP_CODE" -ne 200 ]; then
            echo "ERROR: API call failed with status $HTTP_CODE"
            cat response.json
            exit 1
          fi

          # Extract excerpt and add to parsed data
          EXCERPT=$(jq -r '.content[0].text // "A new blog post"' response.json | tr '\n' ' ' | head -c 150)
          jq --arg excerpt "$EXCERPT" '.excerpt = $excerpt' parsed-data.json > temp.json && mv temp.json parsed-data.json

          echo "✓ Generated excerpt: $EXCERPT"
          echo "=== Contents of parsed-data.json ==="
          cat parsed-data.json
          echo "=== Contents of response.json ==="
          cat response.json

      - name: Create MDX file
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const data = JSON.parse(fs.readFileSync('parsed-data.json', 'utf8'));
            const { title, date, excerpt, slug, imageExt, content, imageUrl } = data;

            // Build frontmatter
            const safeTitle = title.replace(/"/g, '\\"');
            const safeExcerpt = (excerpt || 'A new blog post').replace(/"/g, '\\"');

            const lines = [
              '---',
              `title: "${safeTitle}"`,
              `date: ${date}`,
              `excerpt: "${safeExcerpt}"`,
              '---',
              ''
            ];

            // Add image and content
            if (imageUrl) lines.push(`![Screenshot](/hkia/${slug}.${imageExt})`, '');
            if (content) lines.push(content, '', safeExcerpt, '');

            // Write MDX file
            const filePath = `src/posts/${slug}.mdx`;
            fs.writeFileSync(filePath, lines.join('\n'));
            console.log(`Created ${filePath}`);

      - name: Create Pull Request
        uses: peter-evans/create-pull-request@v6
        id: pr
        with:
          branch: post/${{ steps.parse.outputs.slug }}
          title: "New post: ${{ steps.parse.outputs.title }}"
          body: |
            ## New Blog Post

            **Title:** ${{ steps.parse.outputs.title }}
            **Date:** ${{ steps.parse.outputs.date }}

            ---

            Closes #${{ github.event.issue.number }}
          commit-message: "feat: add blog post - ${{ steps.parse.outputs.title }}"
          base: main

      - name: Comment and close issue
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = '${{ steps.pr.outputs.pull-request-number }}';

            if (prNumber) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: `Blog post PR created!\n\nPR: #${prNumber}`
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: `Blog post files created but PR creation may have failed. Please check the Actions log.`
              });
            }

            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              state: 'closed'
            });

      - name: Cleanup temporary files
        if: always()
        run: |
          echo "Cleaning up temporary files..."
          rm -f parsed-data.json request.json response.json temp.json
          echo "Cleanup complete"
